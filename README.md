# eBPF Benchmark Suite

A comprehensive benchmarking framework for comparing eBPF implementations across multiple languages: **C (libbpf)**, **Python (BCC)**, **Go (ebpf-go)**, and **Rust (Aya)**.

## Overview

This project evaluates the performance characteristics of eBPF programs written in different languages, testing various program types (kprobes, tracepoints, XDP, etc.) and data transfer mechanisms (ring buffers, perf buffers, maps).

## Key Features

- **Multi-Language Support**: C, Python, Go, and Rust eBPF implementations
- **Comprehensive Program Types**: kprobes, tracepoints, uprobes, XDP, TC, raw tracepoints, USDT, perf events
- **Multiple Data Mechanisms**: Ring buffers, perf buffers, hash maps, array maps
- **Automated Benchmarking**: Custom benchmark harness with configurable test scenarios
- **Vagrant Integration**: Pre-configured Ubuntu environment for consistent testing
- **Data Analysis**: Python-based analysis and plotting of results
- **Performance Metrics**: Throughput, latency (P50/P95/P99), CPU usage, memory overhead

## Quick Start

```bash
# Set up directory structure
make setup

# Build all eBPF programs
make build

# Run benchmarks in Vagrant VM
vagrant up
vagrant ssh
make benchmark

# Generate analysis plots
python3 analysis/generate_report.py
```

## How to Run Benchmarks

This eBPF benchmark suite measures the throughput performance of ring buffer event delivery across four different eBPF frameworks. Each implementation traces `openat2` syscalls and reports how many events can be captured and delivered to userspace per second.

### Individual Benchmarks

**C Implementation (libbpf)**
```bash
# Direct execution
/home/vagrant/ebpf_benchmark/build/c/ringbuf_throughput -d 10

# Run for 10 seconds (default), reports events/sec throughput
# Expected: ~100,000 events/sec
```

**Go Implementation (ebpf-go)**
```bash
# Direct execution
/home/vagrant/ebpf_benchmark/build/go/ringbuf_throughput -d 10

# Run for 10 seconds (default), reports events/sec throughput
# Expected: ~27,548 events/sec
```

**Rust Implementation (Aya)**
```bash
# Direct execution
/home/vagrant/ebpf_benchmark/build/rust/ringbuf_throughput -d 10

# Run for 10 seconds (default), reports events/sec throughput
# Expected: ~13,207 events/sec
```

**Python Implementation (BCC)**
```bash
# Requires sudo for kernel probing
sudo python3 -m src.python.ringbuf_throughput -d 10 -v

# Options:
#   -d, --duration: Benchmark duration in seconds (default: 10)
#   -v, --verbose:  Enable verbose output
# Expected: ~2 events/sec
```

### Run All Benchmarks at Once

```bash
# From vagrant VM
bash /home/vagrant/ebpf_benchmark/run_all_benchmarks.sh

# This will:
# 1. Run all four language implementations sequentially
# 2. Capture raw output to /tmp/benchmark_results/
# 3. Display summary of results
# 4. Compare throughput across implementations
```

### Tool Explanation

**What This Benchmark Does**:
- Each implementation loads an eBPF program that traces syscalls at the kernel level
- The traced syscalls (openat2) are captured via kprobe instrumentation
- Events flow through a ring buffer from kernel to userspace
- The benchmark measures how many events can be transferred per second
- Higher throughput = better framework efficiency

**Architecture**:
- **Kernel Component**: eBPF program traces syscalls and writes to ring buffer
- **Userspace Component**: Reads events from ring buffer and counts them
- **Test Duration**: 10 seconds (configurable)
- **Event Source**: openat2 syscalls generated by system activity
- **Performance Metric**: Events per second (throughput)

**Performance Tier Classification**:
- **Tier 1 (High-Performance)**: >10,000 evt/sec → C (libbpf), Go (ebpf-go), Rust (Aya)
- **Tier 2 (Standard)**: 1,000-10,000 evt/sec → Future optimized implementations
- **Tier 3 (Development)**: <100 evt/sec → Python (BCC) - for rapid prototyping

**Key Insights**:
- Performance follows language execution model: compiled < interpreted
- All implementations are production-ready despite performance differences
- Language overhead is acceptable tradeoff for safety/development speed
- Choice should be based on project requirements, not just raw throughput

## Project Structure

```
ebpf_benchmark/
├── src/                          # eBPF program source code
│   ├── c/                        # C (libbpf) implementations
│   ├── python/                   # Python (BCC) implementations
│   ├── golang/                   # Go (ebpf-go) implementations
│   └── rust/                     # Rust (Aya) implementations
├── benchmarks/
│   ├── harness/                  # Benchmark runner framework
│   ├── configs/                  # Benchmark configurations (YAML)
│   ├── results/                  # Test outputs (JSON/CSV)
│   └── scripts/                  # Helper scripts
├── vagrant/                      # Vagrant configuration
├── analysis/
│   ├── plots/                    # Generated comparison plots
│   └── scripts/                  # Python data analysis scripts
├── tests/                        # Unit and integration tests
├── docs/                         # Documentation
└── build/                        # Build artifacts
```

## Benchmark Program Types

### Kernel Tracing
- **kprobes**: Dynamic kernel function entry/exit tracing
- **tracepoints**: Static kernel instrumentation points
- **raw tracepoints**: Direct kernel event tracing

### Userspace Tracing
- **uprobes**: Dynamic userspace function tracing
- **USDT**: Userspace Statically Defined Tracepoints

### Network Processing
- **XDP**: eXpress Data Path (packet processing)
- **TC**: Traffic Control (packet filtering)

### Performance Monitoring
- **perf events**: CPU performance counter sampling

## Data Transfer Mechanisms

- **Ring Buffers**: Single efficient ring buffer (BPF_MAP_TYPE_RINGBUF)
- **Perf Buffers**: Per-CPU ring buffers (BPF_MAP_TYPE_PERFBUF)
- **Hash Maps**: Key-value map operations
- **Array Maps**: Fixed-size array operations

## Benchmark Scenarios

| Scenario | Description | Metrics |
|----------|-------------|---------|
| **Throughput** | Events per second through ring/perf buffers | events/sec, MB/s |
| **Latency** | Time from kernel event to userspace | µs, P50/P95/P99 |
| **Overhead** | System impact of eBPF program execution | CPU %, memory KB |
| **Scalability** | Multi-CPU performance scaling | throughput/core |
| **Complexity** | Impact of program logic on performance | cycles/event |
| **Memory Usage** | Kernel memory footprint | KB, page faults |

## Dependencies

### System Requirements
- Linux kernel 5.8+ (for ring buffers)
- Ubuntu 20.04 LTS or later recommended
- 4+ CPU cores for scalability tests

### Build Dependencies
- LLVM/Clang 12+
- Python 3.8+
- Go 1.18+
- Rust 1.70+

### Runtime Dependencies
- libbpf
- BCC (Python eBPF Compiler Collection)
- ebpf-go
- Aya

## Configuration

Benchmark configurations are defined in YAML files under `benchmarks/configs/`. Example:

```yaml
benchmarks:
  - name: "ring_buffer_throughput"
    program_type: "kprobe"
    data_mechanism: "ring_buffer"
    event_source: "sys_enter_openat"
    duration_seconds: 60
    languages: ["c", "python", "golang", "rust"]
    metrics:
      - throughput
      - latency
      - cpu_usage
      - memory_usage
```

## Running Benchmarks

```bash
# Run all benchmarks
make benchmark

# Run specific language
make benchmark-c
make benchmark-python
make benchmark-golang
make benchmark-rust

# Run specific benchmark
./benchmarks/harness/run_benchmark.py --config ring_buffer_throughput
```

## Results and Analysis

Results are saved to `benchmarks/results/` in JSON format. Generate comparison plots:

```bash
python3 analysis/generate_report.py --results benchmarks/results/*.json
```

This generates:
- Throughput comparison charts
- Latency distribution plots
- CPU/memory overhead analysis
- Scalability graphs
- Summary reports

## Development

### Adding a New Benchmark

1. Create eBPF program in `src/<language>/`
2. Add configuration to `benchmarks/configs/`
3. Implement harness integration
4. Run and collect results

### Contributing

Please follow the contributing guidelines in CONTRIBUTING.md

## License

MIT License - See LICENSE file for details

## Citation

If you use this benchmark suite in research, please cite:

```
@software{ebpf_benchmark_2025,
  title={eBPF Benchmark Suite},
  author={Parlakisik, Murat},
  year={2025},
  url={https://github.com/parlakisik/ebpf_benchmark}
}
```
